---
title: chloropleth
---

```js
// Importation de Leaflet depuis npm pour gérer la carte
import * as L from "npm:leaflet";

// Importation de D3 pour la gestion des échelles de couleurs
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7.6.1/dist/d3.min.js";
```

```js
const statistics = FileAttachment("./data/clusters_statistics.json").json();
```

```js
// Extraction des valeurs pour les différentes statistiques
const geojsonData = statistics;
console.log(statistics)
```


```js
// Initialisation de la carte Leaflet
const mapDiv = display(document.createElement("div"));
mapDiv.style = "height: 600px; width: 100%; margin: 0 auto;";

const map = L.map(mapDiv).setView([-12.81, 45.14], 10.4);

// Ajout de la couche de base OpenStreetMap
const baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors',
});
baseLayer.addTo(map);


function calculateQuantiles(values, quantileProbs) {
  values.sort((a, b) => a - b);
  const quantiles = quantileProbs.map(q => {
    const pos = (values.length - 1) * q;
    const base = Math.floor(pos);
    const rest = pos - base;
    if (values[base + 1] !== undefined) {
      return values[base] + rest * (values[base + 1] - values[base]);
    } else {
      return values[base];
    }
  });
  return quantiles;
}

// Extraction des valeurs pour la propriété 'pct_building_2023'
let values = statistics.features.map(f => f.properties.pct_building_2023);

// Vérifier les valeurs extraites
console.log('Extracted values:', values);

// Vérifier les valeurs invalides
const invalidValues = values.filter(v => v === undefined || isNaN(v));
console.log('Number of invalid values:', invalidValues.length);

// Filtrer les valeurs invalides
values = values.filter(v => v !== undefined && !isNaN(v));

// Définition des probabilités pour les quantiles
const quantileProbs = [0, 0.25, 0.5, 0.75, 1.0];

// Calcul des quantiles avec les valeurs valides
const quantiles = calculateQuantiles(values, quantileProbs);
console.log('Quantiles:', quantiles);

console.log("quantile")
console.log(quantiles)
console.log(quantiles.length)
// Stockage des échelles de couleurs
const colorScales = {
  greenScale: ['#E5FFE5', '#B2FFB2', '#66FF66', '#228B22', '#006400'],
  blueScale: ['#F0F8FF', '#ADD8E6', '#87CEFA', '#4682B4', '#00008B'],
  redScale: ['#FFF0F5', '#FFB6C1', '#FF69B4', '#FF1493', '#FF0066'],
  yellowScale: ['#FFFFCC', '#FEE391', '#FEC44F', '#FE9929', '#D95F0E']
};

function getColor(value, quantiles, colorScale) {
  for (let i = 0; i < quantiles.length - 1; i++) {
    if (value <= quantiles[i + 1]) {
      return colorScale[i];
    }
  }
  // Si la valeur est supérieure au dernier quantile, retourner la dernière couleur
  return colorScale[colorScale.length - 1];
}

function style(feature) {
  return {
    fillColor: getColor(feature.properties.pct_building_2023,quantiles,colorScales["blueScale"]),
    weight: 1,
    opacity: 1,
    color: 'grey',
    fillOpacity: 0.7
  };
}
// Fonction pour ajouter des popups avec les informations
function onEachFeature(feature, layer) {
  if (feature.properties && feature.properties.pct_building_2023) {
    layer.bindPopup('<b>Pourcentage de bâti 2023:</b> ' + feature.properties.pct_building_2023 + '%');
  }
}


// Création de la couche GeoJSON et ajout à la carte
const geojsonLayer = L.geoJson(statistics, {
  style: style,
  onEachFeature: onEachFeature
}).addTo(map);


// Définition des couches de base et des superpositions
const baseLayers = {
  'OpenStreetMap': baseLayer
};

const overlays = {
  'Pourcentage de bâti 2023': geojsonLayer
};

// Ajout du contrôle des couches à la carte
L.control.layers(baseLayers, overlays).addTo(map);
```

```js
// Ajout de la légende
const legend = L.control({position: 'bottomright'});

legend.onAdd = function (map) {
  const div = L.DomUtil.create('div', 'info legend');
  const labels = [];

  div.innerHTML += '<h4>Pourcentage de bâti 2023 (%)</h4>';

  // Boucle pour générer les intervalles de la légende en utilisant les quantiles
  for (let i = 0; i < quantiles.length - 1; i++) {
    const from = quantiles[i];
    const to = quantiles[i + 1];
    const color = colorScales.blueScale[i]; // Utiliser l'échelle de couleurs bleue

    labels.push(
      '<i style="background:' + color + '; width:18px; height:18px; float:left; margin-right:8px; opacity:0.7;"></i> ' +
      Math.round(from) + ' &ndash; ' + Math.round(to)
    );
  }

  div.innerHTML += labels.join('<br>');
  return div;
};

legend.addTo(map);
```
